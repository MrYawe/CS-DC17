
/*_____________________________________________________________

Projet d'optimisation stochastique 2017
Arnaud Steinmetz - Yannis Weishaupt
Assignation de sessions/papiers à un calendrier sur les données du CS-DC15
_______________________________________________________________*/

\User declarations :

#include <string>
#include <cstring>

#include <iostream>
#include <fstream>

#include <cstdio>
#include <cstdlib>

#include <vector>
#include <algorithm>
#include <regex>
#include <iomanip>      // std::get_time
#include <ctime>        // struct std::tm


/*
#define Abs(x) ((x) < 0 ? -(x) : (x))
#define MAX(x,y) ((x)>(y)?(x):(y))
#define MIN(x,y) ((x)<(y)?(x):(y))
*/
#define NB_PAPERS 263 	/* Nombre de papers à placer */
#define NB_DAYS 2


using namespace std;


/* ---------------------------------------------------------------------------- */
/* Valeurs permettant la sélection par la fitness des individus :				*/

#define VALERR0 100000	/* Valeur de pénalité contrainte oblig : eSession superposés avec track15 et papers de même eSession superposé*/
#define VALERR1 1000	/* Valeur de pénalité contrainte forte : papers de même eSession éloigné */

#define VALBON0 1		/* Valeur de bonus faible : éloignement entre eSession*/
#define VALBON1 100		/* Valeur de bonus moyen : respect créneau*/

/* Valeurs du fichier input */
#define PAPER_ID 0
#define TRACK_ID 1
#define SESSION_ID 2
#define DURATION 3
#define UTC 4
#define CONSTRAINT_1 5
#define CONSTRAINT_2 6
#define CONSTRAINT_3 7

/* Classe représentant un cours. Un cours se compose de chaque élément ci-dessous.		*/
class Constraint {
	public:Date start;				/* Début de la contrainte	*/
	public:Date end;				/* Fin de la contrainte		*/
};
/* Classe représentant une classe d'élèves.			*/
class Paper {
	public:int ID;						/* Identifiant du papier 	*/
	public:int TrackID;					/* Identifiant du track		*/
	public:int SessionID;				/* Identifiant de la session*/
	//int posSession;					/* Position dans la session */
	public:int duration;				/* Durée du passage			*/
	public:double timezone;				/* fuseau horaire 			*/

	public:vector<Constraint> day1;	/* Contraintes du jour 1	*/
	public:vector<Constraint> day2;	/* Contraintes du jour 2	*/
	public:vector<Constraint> day3;	/* Contraintes du jour 3	*/

	public:Date date;					/* Date de passage 			*/
};

/********************************************************************************/
/******///             DECLARATION DES VARIABLES GLOBALES               ///******/
/********************************************************************************/

float pMutPerGene = 0.5;		/* probabilité de mutation par individu	*/

clock_t	start, finish;			/* Pour estimer le temps de calcul		*/
double runDuration;				/* temps de calcul						*/

//vector<Constraint> eventDates; 	/* Dates de l'événement 				*/
Constraint* eventDate; 				/* Date de l'événement 				*/

vector<Paper> papers;			/* Liste contenant tous les papers 		*/

/* ---------------------------------------------------------------------------- */
\end

\User functions:
/********************************************************************************/
/******///             DECLARATION DES FONCTIONS GLOBALES               ///******/
/********************************************************************************/

/* Fonction de convertion, permet de changer une valeur numérique en texte pour son affichage	*/
//template<typename T>string chiffre2string(T c) { ostringstream oss; oss << c; return oss.str(); }

void displayConstraint(Constraint c) {
	cout << "    " << c.start.hour << "h" << c.start.min << " à " << c.end.hour << "h" << c.end.min << endl;
}

void displayDate(Date d) {
	cout << "    jour: " << d.nday << " " << d.hour << ":" << d.min << ":" << d.sec << endl;
}

/*void displayEventDate() {
	cout << "Date de l'événement : Du ";

	char mbstr[100];
	char mbstr2[100];

	if (std::strftime(mbstr, sizeof(mbstr), "%F %T", &(eventDate->start))){
		std::cout << mbstr << " au ";
	}
	if (std::strftime(mbstr2, sizeof(mbstr2), "%F %T", &(eventDate->end)))
	{
		std::cout << mbstr2 << endl;
	}
}

void setEventDate() {
	string jour_debut 	= "2015-09-30 06:00:00";
	string jour_fin 	= "2015-10-01 23:59:59";

	eventDate = new Constraint();

	strptime(jour_debut.c_str(), "%F %T", &(eventDate->start));
	strptime(jour_fin.c_str(), "%F %T", &(eventDate->end));
}*/

vector<Constraint> parseConstraints(string subject, int day) {
    vector<Constraint> res;
    std::regex re("\\[(\\d*):(\\d*),(\\d*):(\\d*)\\]");
    std::sregex_iterator next(subject.begin(), subject.end(), re);
    std::sregex_iterator end;

    while (next != end) {
        Constraint* cons = new Constraint();
        std::smatch matches = *next;

		Date d1;
		Date d2;

		d1.nday=day;
		d1.hour=stoi(matches[1].str());
		d1.min=stoi(matches[2].str());
		d1.sec=0;

		d2.nday=day;
		d2.hour=stoi(matches[3].str());
		d2.min=stoi(matches[4].str());
		d2.sec=0;
		//s1 >> std::get_time(&tm1, "%H:%M"); // or just %T in this case
		//s2 >> std::get_time(&tm2, "%H:%M"); // or just %T in this case

		cons->start = d1;
		cons->end = d2;

		//cout << "jour " << day << " " << endl;
		//cout << matches[2].str() << endl;
		//displaytm(cons->start);
		//displaytm(cons->end);

        res.push_back(*cons);
        next++;
    }

    return res;
}

void readPapersFile() {
    std::string delimiter = "|";
    ifstream fPaper;
    fPaper.open("./papers.txt", ios::in);
    string line;
    if (fPaper.is_open()) {
        while ( getline (fPaper,line) ) {

            Paper* p = new Paper();
            int i = 0;
            size_t pos = 0;
            std::string token;

            while ((pos = line.find(delimiter)) != std::string::npos) {
                token = line.substr(0, pos);
                switch ( i ) {
                    case PAPER_ID:
                        p->ID = stoi(token);
                        break;
                    case TRACK_ID:
                        p->TrackID = stoi(token);
                        break;
                    case SESSION_ID:
                        p->SessionID = stoi(token);
                        break;
                    case DURATION:
                        p->duration = stoi(token);
                        break;
                    case UTC:
                        //p->timezone = std::stod(token); // string to float
                    	break;
                    case CONSTRAINT_1:
                        p->day1 = parseConstraints(token, 0);
                        break;
                    case CONSTRAINT_2:
                        p->day2 = parseConstraints(token, 1);
                        break;
                    case CONSTRAINT_3:
                        p->day3 = parseConstraints(token, 2);
                        break;
                }
                line.erase(0, pos + delimiter.length());
                i++;
            }
            papers.push_back(*p);
        }
    }
}

void displayPapers(Paper p) {
    cout << "ID :" << p.ID << endl;
    cout << "TrackID :" << p.TrackID << endl;
    cout << "SessionID :" << p.SessionID << endl;
    cout << "duration :" << p.duration << endl;

    cout << "Disponibilités :" << endl;
    //Affichage des disponibilités
    cout << "  jour 1:" << endl;

    if(p.day1.size()!=0){
    	for(unsigned int i=0; i<p.day1.size(); i++)
		{
			displayConstraint(p.day1[i]);
		}
    } else {
		cout << "    Pas de contraintes" << endl;
    }

	cout << "  jour 2:" << endl;

    if(p.day2.size()!=0){
		for(unsigned int i=0; i<p.day2.size(); i++)
		{
			displayConstraint(p.day2[i]);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}

	cout << "  jour 3:" << endl;
    if(p.day3.size()!=0){
		for(unsigned int i=0; i<p.day3.size(); i++)
		{
			displayConstraint(p.day3[i]);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}


}

int convertDateToMins(Date d) {
	return d.nday*24*60 + d.hour*60 + d.min;
}

int dateOverlappingMins(Date d1, Date d2, int dur1, int dur2) {
	int date1_start = convertDateToMins(d1);
	int date1_end = convertDateToMins(d1)+dur1;

	int date2_start = convertDateToMins(d2);
	int date2_end = convertDateToMins(d2)+dur2;

	int later;
	int early;

	if(date1_start>date2_start) {
		later=date1_start;
		//cout << "date 1 commence plus tard" << endl;
	} else {
		later=date2_start;
		//cout << "date 2 commence plus tard" << endl;
	}
	if(date1_end<date2_end) {
		early=date1_end;
		//cout << "date 1 fini plus tôt" << endl;
	} else {
		early=date2_end;
		//cout << "date 2 fini plus tôt" << endl;
	}
	int score = (early-later);
	if(score<0) {
		score=0;
	}

	/*cout << "dates" << endl;
	displaytm(tm1);
	displaytm(tm2);
	cout << "overlapping score seconds: " << score/3600 << endl;
	cout << "_____" << endl;*/
	return score;
}

int dateOverlappingMinsConstraints(Date d1, int dur1, Constraint c) {
	int date1_start = convertDateToMins(d1);
	int date1_end = convertDateToMins(d1)+dur1;

	int date2_start = convertDateToMins(c.start);
	int date2_end = convertDateToMins(c.end);

	int later;
	int early;

	if(date1_start>date2_start) {
		later=date1_start;
		//cout << "date 1 commence plus tard" << endl;
	} else {
		later=date2_start;
		//cout << "date 2 commence plus tard" << endl;
	}
	if(date1_end<date2_end) {
		early=date1_end;
		//cout << "date 1 fini plus tôt" << endl;
	} else {
		early=date2_end;
		//cout << "date 2 fini plus tôt" << endl;
	}
	int score = (early-later);
	/*if(score<0) {
		score=0;
	}*/

	/*cout << "dates" << endl;
	displaytm(tm1);
	displaytm(tm2);
	cout << "overlapping score seconds: " << score/3600 << endl;
	cout << "_____" << endl;*/
	return score;
}

/* ---------------------------------------------------------------------------- */
\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end


/* ---------------------------------------------------------------------------- */

/********************************************************************************/
/*********///             DECLARATION DES CLASSES               ///**************/
/********************************************************************************/
\User classes :
Date {
	int sec;
	int min;
	int hour;
	int nday;
}

Match {
	int paperID;
	Date date;
}

GenomeClass {
	Match match[NB_PAPERS];
}
\end

\Before everything else function:
	start = clock();

	//setEventDate();
	readPapersFile();


	cout << endl;
	//vector<Constraint> value = papers[0].day1;
	cout << endl;
	//tm start = value.start;
	cout << endl;

	//cout << "test:"<< start.tm_hour << endl;
	//displayConstraint(value);
	//cout << value << endl;


\end

\After everything else function:
	finish = clock();

	runDuration = (double)(finish - start) / CLOCKS_PER_SEC;
	printf("TEMPS D'EXECUTION\t:\t%2.1f secondes\n", runDuration );

	std::cout << "Nb papers :" << papers.size() << "\n";

	//displayPapers(papers[0]);
	//displayPapers(papers[15]);

	//displayEventDate();

	cout << "overlapping constraints : " << endl;
	Date d1;

	d1.nday = 	1;
	d1.hour =	23;
	d1.min =	45;
	d1.sec = 	0;

	int dur1 =	30;

	Constraint c = papers[6].day1[0];

	displayConstraint(c);

	int test = dateOverlappingMinsConstraints(d1, dur1, c);
	cout << " test overlap : " << test << endl;

\end


\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

//PRISE EN COMPTE DU MOIS/ANNEE
\GenomeClass::initialiser : // "initializer" is also accepted
	for(unsigned int i = 0; i < papers.size(); i++) {
		Genome.match[i].paperID = papers[i].ID;

		Genome.match[i].date.sec = 0;
		Genome.match[i].date.min = ((int) random(0,12))*5;
		Genome.match[i].date.hour = (int) random(0,24);
		Genome.match[i].date.nday = (int) random(0, NB_DAYS);
	}
\end

\GenomeClass::crossover :
	// must create "child" out of "parent1" and "parent2"
	float limit = 0.5;

	for (unsigned int i=0; i<NB_PAPERS; i++)
	{
		if((float)random(0.,1.) < limit)
		{ child.match[i].date = parent2.match[i].date; }
	}
\end

\GenomeClass::mutator : // Must return the number of mutations
	unsigned int nbMutations = 0;
	for(unsigned int i = 0; i < papers.size(); i++) {
		if (tossCoin(pMutPerGene)){

			Genome.match[i].date.sec = 0; 
			Genome.match[i].date.min = ((int) random(0,12))*5; 	//0 à 55
			Genome.match[i].date.hour = (int) random(0,24);		//0 à 23
			Genome.match[i].date.nday = (int) random(0, NB_DAYS);

			nbMutations++;
		}
	}
	return nbMutations;
\end

\GenomeClass::evaluator : // Returns the score as a real value
	// Must return an evaluation of the quality of the "Genome"
	//float val[NB_PAPERS];
	float res = 0.;
	float overlap = 0.;
	float overlapDisponibility = 0.;


	for(unsigned int i = 0; i<NB_PAPERS;i++){
		//val[i]=0.;
		for(unsigned int j = 0;j<5;j++) {
			if(i!=j){
				//val[i]-=dateOverlappingSeconds(Genome.match[i].date, Genome.match[j].date, papers[i].duration,papers[j].duration)/3600;
				overlap = dateOverlappingMins(Genome.match[i].date, Genome.match[j].date, papers[i].duration,papers[j].duration);			
				//overlapDisponibility =;
				//float ;

				//if(value!=0.0){
				//	cout << value << endl;
				//}
				res-=overlap;
				//cout << "test : " << dateOverlappingSeconds(Genome.match[i].date, Genome.match[j].date, papers[i].duration,papers[j].duration)/3600 << endl;
			}
		}
	}

  	return res;
\end

\User Makefile options:
CPPFLAGS+=-std=c++11
\end

/*mutation et crossover à 0 pour seqfault*/
\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 1    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 64		   //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:true
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  //Remote island model: true
  //IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  //Server port : 2929

  Save population: false
  //Start from file:false
\end
