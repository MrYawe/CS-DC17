
/*_____________________________________________________________

Projet d'optimisation stochastique 2017
Arnaud Steinmetz - Yannis Weishaupt
Assignation de sessions/papiers à un calendrier sur les données du CS-DC15
_______________________________________________________________*/

\User declarations :

#include <string>
#include <cstring>

#include <iostream>
#include <fstream>

#include <cstdio>
#include <cstdlib>

#include <vector>
#include <algorithm>
#include <regex>
#include <iomanip>      // std::get_time
#include <ctime>        // struct std::tm


/*
#define Abs(x) ((x) < 0 ? -(x) : (x))
#define MAX(x,y) ((x)>(y)?(x):(y))
#define MIN(x,y) ((x)<(y)?(x):(y))
*/
#define NB_PAPERS 263 	/* Nombre de papers à placer */
#define NB_DAYS 2


using namespace std;


/* ---------------------------------------------------------------------------- */
/* Valeurs permettant la sélection par la fitness des individus :				*/

#define VALERR0 100000	/* Valeur de pénalité contrainte oblig : eSession superposés avec track15 et papers de même eSession superposé*/
#define VALERR1 1000	/* Valeur de pénalité contrainte forte : papers de même eSession éloigné */

#define VALBON0 1		/* Valeur de bonus faible : éloignement entre eSession*/
#define VALBON1 100		/* Valeur de bonus moyen : respect créneau*/




/* Valeurs du fichier input */
#define PAPER_ID 0
#define TRACK_ID 1
#define SESSION_ID 2
#define DURATION 3
#define UTC 4
#define CONSTRAINT_1 5
#define CONSTRAINT_2 6
#define CONSTRAINT_3 7

/* Classe représentant un cours. Un cours se compose de chaque élément ci-dessous.		*/
class Constraint {
	public:tm start;			/* Début de la contrainte	*/
	public:tm end;				/* Fin de la contrainte		*/
};
/* Classe représentant une classe d'élèves.			*/
class Paper {
	public:int ID;						/* Identifiant du papier 	*/
	public:int TrackID;					/* Identifiant du track		*/
	public:int SessionID;				/* Identifiant de la session*/
	//int posSession;					/* Position dans la session */
	public:int duration;				/* Durée du passage			*/
	public:double timezone;				/* fuseau horaire 			*/

	public:vector<Constraint> day1;	/* Contraintes du jour 1	*/
	public:vector<Constraint> day2;	/* Contraintes du jour 2	*/
	public:vector<Constraint> day3;	/* Contraintes du jour 3	*/

	public:tm date;					/* Date de passage 			*/
};

/********************************************************************************/
/******///             DECLARATION DES VARIABLES GLOBALES               ///******/
/********************************************************************************/

float pMutPerGene = 0.5;		/* probabilité de mutation par individu	*/

clock_t	start, finish;			/* Pour estimer le temps de calcul		*/
double runDuration;				/* temps de calcul						*/

//vector<Constraint> eventDates; 	/* Dates de l'événement 				*/
Constraint* eventDate; 				/* Date de l'événement 				*/

vector<Paper> papers;			/* Liste contenant tous les papers 		*/

/* ---------------------------------------------------------------------------- */
\end

\User functions:
/********************************************************************************/
/******///             DECLARATION DES FONCTIONS GLOBALES               ///******/
/********************************************************************************/

/* Fonction de convertion, permet de changer une valeur numérique en texte pour son affichage	*/
//template<typename T>string chiffre2string(T c) { ostringstream oss; oss << c; return oss.str(); }
/*
void setEventDates() {

	Constraint* cons1 = new Constraint();
	Constraint* cons2 = new Constraint();

	struct std::tm tm1_debut;
	struct std::tm tm1_fin;
	struct std::tm tm2_debut;
	struct std::tm tm2_fin;

	string jour1_debut 	= "2015-09-30 06:00:00";
	string jour1_fin 	= "2015-09-30 23:59:59";
	string jour2_debut 	= "2015-10-01 00:00:00";
	string jour2_fin 	= "2015-10-01 23:59:59";


    if (strptime(jour1_debut.c_str(), "%F %T", &tm1_debut)){
    	cons1->start=tm1_debut;
    }
    if (strptime(jour1_fin.c_str(), "%F %T", &tm1_fin)){
    	cons1->end=tm1_fin;
    }
    if (strptime(jour2_debut.c_str(), "%F %T", &tm2_debut)){
    	cons2->start=tm2_debut;
    }
    if (strptime(jour2_fin.c_str(), "%F %T", &tm2_fin)){
    	cons2->end=tm2_fin;
    }

    eventDates.push_back(*cons1);
    eventDates.push_back(*cons2);
}*/
void displayConstraint(Constraint c) {
	cout << "    " << c.start.tm_hour << "h" << c.start.tm_min << " à " << c.end.tm_hour << "h" << c.end.tm_min << endl;
}

void displaytm(tm date){
	char mbstr[100];
	if (std::strftime(mbstr, sizeof(mbstr), "%F %T", &date)){
		std::cout << mbstr << endl;
	}
}

void displaytmP(tm* date){
	char mbstr[100];
	if (std::strftime(mbstr, sizeof(mbstr), "%F %T", date)){
		std::cout << mbstr << endl;
	}
}

void displayEventDate() {
	cout << "Date de l'événement : Du ";

	char mbstr[100];
	char mbstr2[100];

	if (std::strftime(mbstr, sizeof(mbstr), "%F %T", &(eventDate->start))){
		std::cout << mbstr << " au ";
	}
	if (std::strftime(mbstr2, sizeof(mbstr2), "%F %T", &(eventDate->end)))
	{
		std::cout << mbstr2 << endl;
	}
}
void setEventDate() {
	string jour_debut 	= "2015-09-30 06:00:00";
	string jour_fin 	= "2015-10-01 23:59:59";

	eventDate = new Constraint();

	strptime(jour_debut.c_str(), "%F %T", &(eventDate->start));
	strptime(jour_fin.c_str(), "%F %T", &(eventDate->end));
}

vector<Constraint> parseConstraints(string subject, int day) {
    vector<Constraint> res;
    std::regex re("\\[(\\d*:\\d*),(\\d*:\\d*)\\]");
    std::sregex_iterator next(subject.begin(), subject.end(), re);
    std::sregex_iterator end;

    while (next != end) {
        Constraint* cons = new Constraint();
        std::smatch matches = *next;

		struct std::tm tm1;
		struct std::tm tm2;
		std::istringstream s1(matches[1].str());
		std::istringstream s2(matches[2].str());
		s1 >> std::get_time(&tm1, "%H:%M"); // or just %T in this case
		s2 >> std::get_time(&tm2, "%H:%M"); // or just %T in this case
		//cons->start = mktime(&tm1);
		//cons->end = mktime(&tm2);
		if(!day) { //TODO TEMPORARY BECAUSE ONLY 2 DAYS
			tm1.tm_year = eventDate->start.tm_year;
			tm1.tm_mon = eventDate->start.tm_mon;
			tm1.tm_mday = eventDate->start.tm_mday;

			tm2.tm_year = eventDate->start.tm_year;
			tm2.tm_mon = eventDate->start.tm_mon;
			tm2.tm_mday = eventDate->start.tm_mday;
		} else {
			tm1.tm_year = eventDate->end.tm_year;
			tm1.tm_mon = eventDate->end.tm_mon;
			tm1.tm_mday = eventDate->end.tm_mday;

			tm2.tm_year = eventDate->end.tm_year;
			tm2.tm_mon = eventDate->end.tm_mon;
			tm2.tm_mday = eventDate->end.tm_mday;
		}
		tm1.tm_sec=0;
		tm2.tm_sec=0;

		cons->start = tm1;
		cons->end = tm2;

		//cout << "jour " << day << " " << endl;
		//cout << matches[2].str() << endl;
		//displaytm(cons->start);
		//displaytm(cons->end);

        res.push_back(*cons);
        next++;
    }

    return res;
}

void readPapersFile() {
    std::string delimiter = "|";
    ifstream fPaper;
    fPaper.open("./papers.txt", ios::in);
    string line;
    if (fPaper.is_open()) {
        while ( getline (fPaper,line) ) {

            Paper* p = new Paper();
            int i = 0;
            size_t pos = 0;
            std::string token;

            while ((pos = line.find(delimiter)) != std::string::npos) {
                token = line.substr(0, pos);
                switch ( i ) {
                    case PAPER_ID:
                        p->ID = stoi(token);
                        break;
                    case TRACK_ID:
                        p->TrackID = stoi(token);
                        break;
                    case SESSION_ID:
                        p->SessionID = stoi(token);
                        break;
                    case DURATION:
                        p->duration = stoi(token);
                        break;
                    case UTC:
                        //p->timezone = std::stod(token); // string to float
                    	break;
                    case CONSTRAINT_1:
                        p->day1 = parseConstraints(token, 0);
                        break;
                    case CONSTRAINT_2:
                        p->day2 = parseConstraints(token, 1);
                        break;
                    case CONSTRAINT_3:
                        p->day3 = parseConstraints(token, 2);
                        break;
                }
                line.erase(0, pos + delimiter.length());
                i++;
            }
            papers.push_back(*p);
        }
    }
}




/*void displayEventDates() {
	cout << "Dates de l'événement :" << endl;
	for(unsigned int i = 0; i<eventDates.size();i++){
		cout << "jour " << i << ": ";
		displayConstraint(eventDates[i], 1);
	}
}*/

void displayPapers(Paper p) {
    cout << "ID :" << p.ID << endl;
    cout << "TrackID :" << p.TrackID << endl;
    cout << "SessionID :" << p.SessionID << endl;
    cout << "duration :" << p.duration << endl;

    cout << "Disponibilités :" << endl;
    //Affichage des disponibilités
    cout << "  jour 1:" << endl;

    if(p.day1.size()!=0){
    	for(unsigned int i=0; i<p.day1.size(); i++)
		{
			displayConstraint(p.day1[i]);
		}
    } else {
		cout << "    Pas de contraintes" << endl;
    }

	cout << "  jour 2:" << endl;

    if(p.day2.size()!=0){
		for(unsigned int i=0; i<p.day2.size(); i++)
		{
			displayConstraint(p.day2[i]);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}

	cout << "  jour 3:" << endl;
    if(p.day3.size()!=0){
		for(unsigned int i=0; i<p.day3.size(); i++)
		{
			displayConstraint(p.day3[i]);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}


}

/*
	int min;
	int hour;
	int day;
	int mon;
	int year;
*/

int convertDateToMinValue(Date d){
	return (d.year * 365 + d.mon * 31 + d.day * 24 + d.hour * 60 + d.min);
}

/*int dateOverlappingScore(Date d1, Date d2, int dur1, int dur2) {
	int res = 0;

	tm tm1;
	tm1.tm_year=	d1.year-1900;
	tm1.tm_mon=		d1.mon;
	tm1.tm_mday=	d1.day;
	tm1.tm_hour=	d1.hour;
	tm1.tm_min=		d1.min;
	tm1.tm_sec=		32;
	tm tm2;
	tm2.tm_year=	d2.year-1900;
	tm2.tm_mon=		d2.mon;
	tm2.tm_mday=	d2.day;
	tm2.tm_hour=	d2.hour;
	tm2.tm_sec=		0;

	tm* tm1_end = new tm(tm1);
	displaytm(tm1);
	displaytm(*tm1_end);

	time_t sec1 = mktime(&tm1);
	time_t sec1_end = mktime(tm1_end)+dur1*60;

	cout << "debut :" << sec1 << endl;
	cout << "fin :" << sec1_end << endl;

	cout << "difference : " << difftime(sec1,sec1_end) << endl;

	return res;
}*/

int dateOverlappingSeconds(Date d1, Date d2, int dur1, int dur2) {
	//A changer selon l'initialisation
	tm tm1;
	tm1.tm_year=	d1.year;
	tm1.tm_mon=		d1.mon;
	tm1.tm_mday=	d1.day;
	tm1.tm_hour=	d1.hour;
	tm1.tm_min=		d1.min;
	tm1.tm_sec=		0;
	tm tm2;
	tm2.tm_year=	d2.year;
	tm2.tm_mon=		d2.mon;
	tm2.tm_mday=	d2.day;
	tm2.tm_hour=	d2.hour;
	tm2.tm_min=		d2.min;
	tm2.tm_sec=		0;

	/*cout << "dates" << endl;
	displaytm(tm1);
	displaytm(tm2);
	cout << "_____" << endl;*/

	//tm* tm1_end = new tm(tm1);

	time_t date1_start = mktime(&tm1);
	time_t date1_end = mktime(&tm1)+dur1*60;

	time_t date2_start = mktime(&tm2);
	time_t date2_end = mktime(&tm2)+dur2*60;

	time_t later;
	time_t early;

	if(difftime(date1_start, date2_start)>0) {
		later=date1_start;
		//cout << "date 1 commence plus tard" << endl;
	} else {
		later=date2_start;
		//cout << "date 2 commence plus tard" << endl;
	}
	if(difftime(date1_end,date2_end)<0) {
		early=date1_end;
		//cout << "date 1 fini plus tôt" << endl;
	} else {
		early=date2_end;
		//cout << "date 2 fini plus tôt" << endl;
	}
	int score = (early-later);
	if(score<0) {
		score=0;
	}

	/*cout << "dates" << endl;
	displaytm(tm1);
	displaytm(tm2);
	cout << "overlapping score seconds: " << score/3600 << endl;
	cout << "_____" << endl;*/
	return score;
}

/* ---------------------------------------------------------------------------- */
\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end


/* ---------------------------------------------------------------------------- */

/********************************************************************************/
/*********///             DECLARATION DES CLASSES               ///**************/
/********************************************************************************/
\User classes :
Date {
	int min;
	int hour;
	int day;
	int mon;
	int year;
}

Match {
	int paperID;
	Date date;
}

GenomeClass {
	Match match[NB_PAPERS];
}
\end

\Before everything else function:
	start = clock();

	cout << endl;


	//vector<Constraint> value = papers[0].day1;

	cout << endl;


	//tm start = value.start;

	cout << endl;

	//cout << "test:"<< start.tm_hour << endl;
	//displayConstraint(value);
	//cout << value << endl;

	/*for(unsigned int i = 0;i<NB_PAPERS;i++) {
		for (unsigned int j = 0;j<papers[i].day1.size();j++) {
			cout << "start paper " << i << "jour " << j << " : "<< &(papers[i].day1[j].start) << endl;
		}
	}*/

    setEventDate();
	readPapersFile();
\end

\After everything else function:
	finish = clock();

	runDuration = (double)(finish - start) / CLOCKS_PER_SEC;
	printf("TEMPS D'EXECUTION\t:\t%2.1f secondes\n", runDuration );

	std::cout << "Nb papers :" << papers.size() << "\n";

	displayPapers(papers[0]);

	displayEventDate();

/*
	Date d1;
	Date d2;

	d1.year	=	2015;
	d1.mon =	4;
	d1.day =	3;
	d1.hour =	22;
	d1.min =	15;

	d2.year	=	2015;
	d2.mon =	4;
	d2.day =	3;
	d2.hour =	10;
	d2.min =	00;

	int dur1 =	30;
	int dur2 =  60;

	int test = dateOverlappingSeconds(d1,d2,dur1,dur2);

	cout << "check overlap : "<< test << endl;*/
\end


\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

//PRISE EN COMPTE DU MOIS/ANNEE
\GenomeClass::initialiser : // "initializer" is also accepted
	for(unsigned int i = 0; i < papers.size(); i++) {
		Genome.match[i].paperID = papers[i].ID;
		Genome.match[i].date.year = eventDate->start.tm_year;
		Genome.match[i].date.min = ((int) random(0,12))*5;
		Genome.match[i].date.hour = (int) random(0,24);
		Genome.match[i].date.mon = eventDate->start.tm_mon;

		int rDay = (int) random(0, NB_DAYS);
		int dayValue = (eventDate->start.tm_mday + rDay) % 31;
		if(!dayValue) {
			dayValue++;
			Genome.match[i].date.mon++;
		}
		Genome.match[i].date.day = dayValue;
	}
\end

\GenomeClass::crossover :
	// must create "child" out of "parent1" and "parent2"
	float limit = 0.5;

	for (unsigned int i=0; i<NB_PAPERS; i++)
	{
		if((float)random(0.,1.) < limit)
		{ child.match[i].date = parent2.match[i].date; }
	}
\end

\GenomeClass::mutator : // Must return the number of mutations
	unsigned int nbMutations = 0;
	for(unsigned int i = 0; i < papers.size(); i++) {
		if (tossCoin(pMutPerGene)){
			Genome.match[i].date.min = ((int) random(0,12))*5; 	//0 à 55
			Genome.match[i].date.hour = (int) random(0,24);		//0 à 23
			Genome.match[i].date.mon = eventDate->start.tm_mon;	//0 à 11

			int rDay = (int) random(0, NB_DAYS);
			int dayValue = (eventDate->start.tm_mday + rDay) % 31;
			if(!dayValue) {
				dayValue++;
				Genome.match[i].date.mon++;//attention décembre
			}
			Genome.match[i].date.day = dayValue;
			nbMutations++;
		}
	}
	return nbMutations;
\end

\GenomeClass::evaluator : // Returns the score as a real value
	// Must return an evaluation of the quality of the "Genome"
	//float val[NB_PAPERS];
	float res = 0.;
	for(unsigned int i = 0; i<NB_PAPERS;i++){
		//val[i]=0.;
		for(unsigned int j = 0;j<5;j++) {
			if(i!=j){
				//val[i]-=dateOverlappingSeconds(Genome.match[i].date, Genome.match[j].date, papers[i].duration,papers[j].duration)/3600;
				float overlap = dateOverlappingSeconds(Genome.match[i].date, Genome.match[j].date, papers[i].duration,papers[j].duration)/3600;
				//float ;

				//if(value!=0.0){
				//	cout << value << endl;
				//}
				res-=overlap;
				//cout << "test : " << dateOverlappingSeconds(Genome.match[i].date, Genome.match[j].date, papers[i].duration,papers[j].duration)/3600 << endl;
			}
		}
	}

  	return res;
\end

\User Makefile options:
CPPFLAGS+=-std=c++11
\end

/*mutation et crossover à 0 pour seqfault*/
\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 10    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 64		   //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:true
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  //Remote island model: true
  //IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  //Server port : 2929

  Save population: false
  //Start from file:false
\end
