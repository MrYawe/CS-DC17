
/*_____________________________________________________________

Projet d'optimisation stochastique 2017
Arnaud Steinmetz - Yannis Weishaupt
Assignation de sessions/papiers à un calendrier sur les données du CS-DC15
_______________________________________________________________*/

\User declarations : 

#include <math.h>
#include <cstring>
#include <stdio.h> 
#include <stdlib.h> 
#include <time.h>

/*
#include <string>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <algorithm>
*/


#define Abs(x) ((x) < 0 ? -(x) : (x))
#define MAX(x,y) ((x)>(y)?(x):(y))
#define MIN(x,y) ((x)<(y)?(x):(y))

#define NBPAPERS 263 	/* Nombre de papers à placer */


using namespace std;


/* ---------------------------------------------------------------------------- */
/* Valeurs permettant la sélection par la fitness des individus :				*/

#define VALERR0 100000	/* Valeur de pénalité contrainte oblig	*/
#define VALERR1 1000	/* Valeur de pénalité contrainte forte	*/
#define VALERR2 1		/* Valeur de pénalité contrainte faible */

/********************************************************************************/
/******///             DECLARATION DES VARIABLES GLOBALES               ///******/
/********************************************************************************/

float pMutPerGene = 0.5;	/* probabilité de mutation par individu	*/

clock_t	start, finish;		/* Pour estimer le temps de calcul		*/
double duration;			/* temps de calcul						*/

/* ---------------------------------------------------------------------------- */
\end

\User functions:
/********************************************************************************/
/******///             DECLARATION DES FONCTIONS GLOBALES               ///******/
/********************************************************************************/

/* Fonction d'affichage, utilisée pour mettre des tirets.	*/
string cmpTiret(int unsigned n)
	{ string Emot = ""; while (Emot.length() < n) { Emot += "-"; } return Emot; }

/* Fonctions d'affichage, utilisées pour placer des espaces à coté du texte.*/
string cmpEspaceAlignGauche(string mot, int unsigned n)
	{ string Emot = mot; if ((Emot.length() > n) && (n > 2)) { Emot = mot.substr(0,n-3) + "..."; }
	while (Emot.length() < n) { Emot = Emot + " "; } return Emot; }
string cmpEspaceAlignCentre(string mot, int unsigned n)
	{ string Emot = mot; bool pos = true; if ((Emot.length() > n) && (n > 2)) { Emot = mot.substr(0,n-3) + "..."; }
	while (Emot.length() < n) { if (pos) { Emot = Emot + " "; pos = false; }  else { Emot = " " + Emot; pos = true; } } return Emot; }
string cmpEspaceAlignDroite(string mot, int unsigned n)
	{ string Emot = mot; if ((Emot.length() > n) && (n > 2)) { Emot = mot.substr(0,n-3) + "..."; }
	while (Emot.length() < n) { Emot = + " " + Emot; } return Emot; }

/* Fonction de convertion, permet de changer une valeur numérique en texte pour son affichage	*/
template<typename T>
string chiffre2string(T c) { ostringstream oss; oss << c; return oss.str(); }

/* ---------------------------------------------------------------------------- */
\end


/********************************************************************************/
/****///             DECLARATION DES FONCTIONS TEMPORELLES               ///*****/
/********************************************************************************/
\Before everything else function:
/* Sauvegarde de l'heure de début du calcul	*/
	start = clock();
\end

\After everything else function:
/* Sauvegarde de l'heure de fin du calcul	*/
	finish = clock();
/* Affichage du meilleur individu			*/
	//bBest->printOn(cout);

/* Affichage de l'estimation du temps de calcul*/
	duration = (double)(finish - start) / CLOCKS_PER_SEC;
	//cout<<"OBJECTIF\t\t:\t"<<"Atteindre 0 pts."<<endl;
	//cout<<"MEILLEUR SCORE\t\t:\t"<<bBest->evaluate()<<" pts"<<endl;
	printf("TEMPS D'EXECUTION\t:\t%2.1f secondes\n", duration );
\end

\At the beginning of each generation function:
// cout<<"(DEB) FITNESS : "<<bBest->evaluate()<<endl;
\end

\At the end of each generation function:
// cout<<"(FIN) FITNESS : "<<bBest->evaluate()<<endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end
/* ---------------------------------------------------------------------------- */

/********************************************************************************/
/*********///             DECLARATION DES CLASSES               ///**************/
/********************************************************************************/
\User classes :

/* Classe représentant un cours. Un cours se compose de chaque élément ci-dessous.		*/
ConstraintsClass
{
	int start			/* Début de la contrainte	*/
	int end;			/* Fin de la contrainte		*/
}
/* Classe représentant une classe d'élèves.			*/
PapersClass
{
	int ID;						/* Identifiant du papier 	*/
	int IDTrack;				/* Identifiant du track		*/
	int IDeSession;				/* Identifiant de la session*/
	//int posSession;			/* Position dans la session */
	int duration;				/* Durée du passage			*/
	float timezone;				/* fuseau horaire 			*/

	vector<Constraint> day1;	/* Contraintes du jour 1	*/	
	vector<Constraint> day2;	/* Contraintes du jour 2	*/
	vector<Constraint> day3;	/* Contraintes du jour 3	*/

	tm date;					/* Date de passage 			*/
}
/* Classe représentant un enseignant.									*/
SessionsClass
{
	int ID 						/* Identifiant de la session			*/
	tm date 					/* Date de la session 					*/
	Vector<Paper> papers 		/* Ensemble des papiers dans la session */
}

/* Classe représentant un génome, soit un emplois du temps complet.	*/
GenomeClass
{ 
	int papers[NBPAPERS];	/* tableau contenant l'identifiant des papers 	*/
	//int dates[NBPAPERS];	/* tableau contenant les dates attribuées 		*/
	int scores[NBPAPERS];	/* tableau contenant les scores attribués		*/
}

/*
typedef struct{
	int start;
	int end;
}Constraint;

typedef struct{
	int ID;
	int IDTrack;
	int IDeSession;
	int posSession;
	int duration;
	float timezone;

	vector<Constraint> day1;
	vector<Constraint> day2;
	vector<Constraint> day3;

	tm date;
}Paper;

typedef struct{
	int ID;
	tm date;
	vector<Paper> papers;
}Session;

*/

\end


/************************************************************************************************/
/********************///                     AFFICHAGE                     ///*******************/
/************************************************************************************************/

\GenomeClass::display:
/* -------------------------------------------------------------------------------------------- */
/* DECLARATION DES VARIABLES																	*/
/* -------------------------------------------------------------------------------------------- */



/* -------------------------------------------------------------------------------------------- */
/* AFFICHAGE DE L'EDT																			*/
/* -------------------------------------------------------------------------------------------- */


/* -------------------------------------------------------------------------------------------- */
/* AFFICHAGE DE L'EVALUATION 																					*/
/* -------------------------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------------------------- */
\end



/************************************************************************************************/
/********************///                  INITIALISATION                   ///*******************/
/************************************************************************************************/

\GenomeClass::initialiser :


\end
/* -------------------------------------------------------------------------------------------- */


/************************************************************************************************/
/********************///                     CROSS-OVER                    ///*******************/
/************************************************************************************************/

\GenomeClass::crossover :

/*
float	limite			= 0.5;

for (int i=0; i<NBCOURS; i++)
{
	if((float)random(0.,1.) < limite)
	{ child.cours[i].creneau = parent2.cours[i].creneau; }
}*/

\end
/* -------------------------------------------------------------------------------------------- */


/************************************************************************************************/
/********************///                      MUTATION                     ///*******************/
/************************************************************************************************/

\GenomeClass::mutator : // retourne le nombre de mutations

int	nb = 0;

/* -------------------------------------------------------------------------------------------- */
/* EVALUATION DES CRENEAUX									*/
/* -------------------------------------------------------------------------------------------- */


return nb;

\end
/* -------------------------------------------------------------------------------------------- */


/************************************************************************************************/
/********************///                     EVALUATION                    ///*******************/
/************************************************************************************************/

\GenomeClass::evaluator : // retourne le score

/* Méthode réutilisée dans l'affichage (voir plus haut dans le code) et y est commentée		*/

/* -------------------------------------------------------------------------------------------- */
/* DECLARATION DES VARIABLES																	*/
/* -------------------------------------------------------------------------------------------- */


/* -------------------------------------------------------------------------------------------- */
/* EVALUATION DE L'AFFECTATION (
	on pourrait séparer :
	- évaluation speaker (contrainte)
	- évaluation session (cassure)
	- 																							*/
/* -------------------------------------------------------------------------------------------- */



/* -------------------------------------------------------------------------------------------- */
/* RETOUR DU SCORE										*/
/* -------------------------------------------------------------------------------------------- */

//score = totalR0 * VALERR0 + totalR1 * VALERR1 + totalR2 * VALERR2;
//return score;

\end
/* -------------------------------------------------------------------------------------------- */


/************************************************************************************************/
/********************///                     PARAMETRAGE                    ///******************/
/************************************************************************************************/

\User Makefile options: 
CPPFLAGS+=
\end

\Default run parameters :       		// Please let the parameters appear in this order

  Number of generations :	100	     		// NB_GEN
  Time limit:			10 			// In seconds, 0 to deactivate
  Population size :		100			// POP_SIZE
  Offspring size :		40%			// 40% 
  Mutation probability :	1       		// MUT_PROB
  Crossover probability :	1	      		// XOVER_PROB
  Evaluator goal :		Minimise      		// Maximise
  Selection operator:		Tournament 2.0
  Surviving parents:		90%			// percentage or absolute  
  Surviving offspring:		90%
  Reduce parents operator:	Tournament 2
  Reduce offspring operator:	Tournament 2
  Final reduce operator:	Tournament 2

  Elitism:			Strong			//Weak or Strong
  Elite:			1
  Print stats:			true			//Default: 1
  Generate csv stats file:	false			
  Generate gnuplot script:	false
  Generate R script:		false
  Plot stats:			false			//Default: 0

  Remote island model:		false
  IP file:			ip.txt 			//File containing all the remote island's IP
  Migration probability:	0

  Save population:		true
  Start from file:		false


  /** option des gens de 2015 
    Number of generations : 300    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 64		   //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute  
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:true			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  Remote island model: true
  IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  Server port : 2929

  Save population: false
  Start from file:false
  */
  
\end
/* -------------------------------------------------------------------------------------------- */ 