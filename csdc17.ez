
/*_____________________________________________________________

Projet d'optimisation stochastique 2017
Arnaud Steinmetz - Yannis Weishaupt
Assignation de sessions/papiers à un calendrier sur les données du CS-DC15
_______________________________________________________________*/

\User declarations :

#include <string>
#include <cstring>

#include <iostream>
#include <fstream>

#include <cstdio>
#include <cstdlib>

#include <vector>
#include <algorithm>
#include <regex>
#include <iomanip>      // std::get_time
#include <ctime>        // struct std::tm


/*
#define Abs(x) ((x) < 0 ? -(x) : (x))
#define MAX(x,y) ((x)>(y)?(x):(y))
#define MIN(x,y) ((x)<(y)?(x):(y))
*/
#define NBPAPERS 263 	/* Nombre de papers à placer */


using namespace std;


/* ---------------------------------------------------------------------------- */
/* Valeurs permettant la sélection par la fitness des individus :				*/

#define VALERR0 100000	/* Valeur de pénalité contrainte oblig	*/
#define VALERR1 1000	/* Valeur de pénalité contrainte forte	*/
#define VALERR2 1		/* Valeur de pénalité contrainte faible */


/* Valeurs du fichier input */
#define PAPER_ID 0
#define TRACK_ID 1
#define SESSION_ID 2
#define DURATION 3
#define UTC 4
#define CONSTRAINT_1 5
#define CONSTRAINT_2 6
#define CONSTRAINT_3 7

/* Classe représentant un cours. Un cours se compose de chaque élément ci-dessous.		*/
class Constraint {
	public:tm start;			/* Début de la contrainte	*/
	public:tm end;			/* Fin de la contrainte		*/
};
/* Classe représentant une classe d'élèves.			*/
class Paper {
	public:int ID;						/* Identifiant du papier 	*/
	public:int TrackID;				/* Identifiant du track		*/
	public:int SessionID;				/* Identifiant de la session*/
	//int posSession;			/* Position dans la session */
	public:int duration;				/* Durée du passage			*/
	public:double timezone;				/* fuseau horaire 			*/

	public:vector<Constraint> day1;	/* Contraintes du jour 1	*/
	public:vector<Constraint> day2;	/* Contraintes du jour 2	*/
	public:vector<Constraint> day3;	/* Contraintes du jour 3	*/

	public:tm date;					/* Date de passage 			*/
};

/********************************************************************************/
/******///             DECLARATION DES VARIABLES GLOBALES               ///******/
/********************************************************************************/

float pMutPerGene = 0.5;		/* probabilité de mutation par individu	*/

clock_t	start, finish;			/* Pour estimer le temps de calcul		*/
double runDuration;				/* temps de calcul						*/

vector<Constraint> eventDates; 	/* Dates de l'événement 				*/
vector<Paper> papers;			/* Liste contenant tous les papers 		*/

/* ---------------------------------------------------------------------------- */
\end

\User functions:
/********************************************************************************/
/******///             DECLARATION DES FONCTIONS GLOBALES               ///******/
/********************************************************************************/

/* Fonction de convertion, permet de changer une valeur numérique en texte pour son affichage	*/
//template<typename T>string chiffre2string(T c) { ostringstream oss; oss << c; return oss.str(); }

void setEventDates() {

	Constraint* cons1 = new Constraint();
	Constraint* cons2 = new Constraint();

	struct std::tm tm1_debut;
	struct std::tm tm1_fin;
	struct std::tm tm2_debut;
	struct std::tm tm2_fin;

	string jour1_debut 	= "2015-09-30 06:00:00";
	string jour1_fin 	= "2015-09-30 23:59:59";
	string jour2_debut 	= "2015-10-01 00:00:00";
	string jour2_fin 	= "2015-10-01 23:59:59";


    if (strptime(jour1_debut.c_str(), "%F %T", &tm1_debut)){
    	cons1->start=tm1_debut;
    } 
    if (strptime(jour1_fin.c_str(), "%F %T", &tm1_fin)){
    	cons1->end=tm1_fin;
    } 
    if (strptime(jour2_debut.c_str(), "%F %T", &tm2_debut)){
    	cons2->start=tm2_debut;
    } 
    if (strptime(jour2_fin.c_str(), "%F %T", &tm2_fin)){
    	cons2->end=tm2_fin;
    } 

    eventDates.push_back(*cons1);
    eventDates.push_back(*cons2);
}

vector<Constraint> parseConstraints(string subject) {
    vector<Constraint> res;
    std::regex re("\\[(\\d*:\\d*),(\\d*:\\d*)\\]");
    std::sregex_iterator next(subject.begin(), subject.end(), re);
    std::sregex_iterator end;

    while (next != end) {
        Constraint* cons = new Constraint();
        std::smatch matches = *next;

				struct std::tm tm1;
				struct std::tm tm2;
				std::istringstream s1(matches[1].str());
				std::istringstream s2(matches[2].str());
				s1 >> std::get_time(&tm1, "%H:%M"); // or just %T in this case
				s2 >> std::get_time(&tm2, "%H:%M"); // or just %T in this case
				//cons->start = mktime(&tm1);
        //cons->end = mktime(&tm2);
				cons->start = tm1;
				cons->end = tm2;

        res.push_back(*cons);
        next++;
    }

    return res;
}

void readPapersFile() {
    std::string delimiter = "|";
    ifstream fPaper;
    fPaper.open("./papers.txt", ios::in);
    string line;
    if (fPaper.is_open()) {
        while ( getline (fPaper,line) ) {

            Paper* p = new Paper();
            int i = 0;
            size_t pos = 0;
            std::string token;

            while ((pos = line.find(delimiter)) != std::string::npos) {
                token = line.substr(0, pos);
                switch ( i ) {
                    case PAPER_ID:
                        p->ID = stoi(token);
                        break;
                    case TRACK_ID:
                        p->TrackID = stoi(token);
                        break;
                    case SESSION_ID:
                        p->SessionID = stoi(token);
                        break;
                    case DURATION:
                        p->duration = stoi(token);
                        break;
                    case UTC:
                        //p->timezone = std::stod(token); // string to float
                    	break;
                    case CONSTRAINT_1:
                        p->day1 = parseConstraints(token);
                        break;
                    case CONSTRAINT_2:
                        p->day2 = parseConstraints(token);
                        break;
                    case CONSTRAINT_3:
                        p->day3 = parseConstraints(token);
                        break;
                }
                line.erase(0, pos + delimiter.length());
                i++;
            }
            papers.push_back(*p);
        }
    }
}



void displayConstraint(Constraint c, int boolFullDate) {
	if(boolFullDate) {
		cout << c.start.tm_mday << "-" << c.start.tm_mon << "-" << c.start.tm_year;
	}
	cout << "    " << c.start.tm_hour << "h" << c.start.tm_min << " à " << c.end.tm_hour << "h" << c.end.tm_min << endl;
}

void displayEventDates() {
	cout << "Dates de l'événement :" << endl;
	for(unsigned int i = 0; i<eventDates.size();i++){
		cout << "jour " << i << ": "; 
		displayConstraint(eventDates[i], 1);
	}
}

void displayPapers(Paper p) {
    cout << "ID :" << p.ID << endl;
    cout << "TrackID :" << p.TrackID << endl;
    cout << "SessionID :" << p.SessionID << endl;
    cout << "duration :" << p.duration << endl;

    cout << "Disponibilités :" << endl;
    //Affichage des disponibilités
    cout << "  jour 1:" << endl;

    if(p.day1.size()!=0){
    	for(unsigned int i=0; i<p.day1.size(); i++)
		{
			displayConstraint(p.day1[i], 0);
		}
    } else {
		cout << "    Pas de contraintes" << endl;
    }
    
	cout << "  jour 2:" << endl;

    if(p.day2.size()!=0){
		for(unsigned int i=0; i<p.day2.size(); i++)
		{
			displayConstraint(p.day2[i], 0);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}

	cout << "  jour 3:" << endl;
    if(p.day3.size()!=0){
		for(unsigned int i=0; i<p.day3.size(); i++)
		{
			displayConstraint(p.day3[i], 0);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}

    
}

/* ---------------------------------------------------------------------------- */
\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end


/* ---------------------------------------------------------------------------- */

/********************************************************************************/
/*********///             DECLARATION DES CLASSES               ///**************/
/********************************************************************************/
\User classes :


GenomeClass {
	int papersID[NBPAPERS];
}


\end

\Before everything else function:
	start = clock();

    setEventDates();
	readPapersFile();
\end

\After everything else function:
	finish = clock();

	runDuration = (double)(finish - start) / CLOCKS_PER_SEC;
	printf("TEMPS D'EXECUTION\t:\t%2.1f secondes\n", runDuration );

	std::cout << "Nb papers :" << papers.size() << "\n";

	displayPapers(papers[0]);

	displayEventDates();



	
\end


\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted

\end

\GenomeClass::crossover :
  // must create "child" out of "parent1" and "parent2"

\end

\GenomeClass::mutator : // Must return the number of mutations

\end

\GenomeClass::evaluator : // Returns the score as a real value

\end

\User Makefile options: 
CPPFLAGS+=-std=c++11
\end

/*mutation et crossover à 0 pour seqfault*/
\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 300    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 64		   //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:true
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  //Remote island model: true
  //IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  //Server port : 2929

  Save population: false
  //Start from file:false
\end
