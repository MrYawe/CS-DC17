
/*_____________________________________________________________

Projet d'optimisation stochastique 2017
Arnaud Steinmetz - Yannis Weishaupt
Assignation de sessions/papiers à un calendrier sur les données du CS-DC15
_______________________________________________________________*/

\User declarations :

#include <string>
#include <cstring>

#include <iostream>
#include <fstream>

#include <cstdio>
#include <cstdlib>

#include <vector>
#include <algorithm>
#include <regex>
#include <iomanip>      // std::get_time
#include <ctime>        // struct std::tm


/*
#define Abs(x) ((x) < 0 ? -(x) : (x))
#define MAX(x,y) ((x)>(y)?(x):(y))
#define MIN(x,y) ((x)<(y)?(x):(y))
*/

#define NB_SESSIONS 54 	/* Nombre de sessions */
#define NB_PAPERS 263 	/* Nombre de papers à placer */
#define NB_DAYS 2


using namespace std;


/* ---------------------------------------------------------------------------- */
/* Valeurs permettant la sélection par la fitness des individus :				*/

#define VALERR0 100000	/* Valeur de pénalité contrainte oblig : eSession superposés avec track15 et papers de même eSession superposé*/
#define VALERR1 1000	/* Valeur de pénalité contrainte forte : papers de même eSession éloigné */

#define VALBON0 1		/* Valeur de bonus faible : éloignement entre eSession*/
#define VALBON1 100		/* Valeur de bonus moyen : respect créneau*/


#define NB_PAPERS_BY_SESSION 50

/* Valeurs du fichier input */
#define PAPER_ID 0
#define TRACK_ID 1
#define SESSION_ID 2
#define DURATION 3
#define UTC 4
#define CONSTRAINT_1 5
#define CONSTRAINT_2 6
#define CONSTRAINT_3 7

/* Classe représentant un cours. Un cours se compose de chaque élément ci-dessous.		*/
class Constraint {
	public:Date start;				/* Début de la contrainte	*/
	public:Date end;				/* Fin de la contrainte		*/
};
/* Classe représentant une classe d'élèves.			*/

class Paper {
	public:int ID;						/* Identifiant du papier 	*/
	public:int TrackID;					/* Identifiant du track		*/
	public:int SessionID;				/* Identifiant de la session*/
	//int posSession;					/* Position dans la session */
	public:int duration;				/* Durée du passage			*/
	public:double timezone;				/* fuseau horaire 			*/

	public:vector<Constraint> day1;	/* Contraintes du jour 1	*/
	public:vector<Constraint> day2;	/* Contraintes du jour 2	*/
	public:vector<Constraint> day3;	/* Contraintes du jour 3	*/

	public:Date date;					/* Date de passage 			*/
};

class Session {
	public:int ID;
	public:int TrackID;
	public:int duration;
	public:vector<Paper*> papers;
};

class Track {
	public:int ID;
	public:vector<Session*> sessions;
};



/********************************************************************************/
/******///             DECLARATION DES VARIABLES GLOBALES               ///******/
/********************************************************************************/

float pMutPerGene = 0.5;		/* probabilité de mutation par individu	*/

clock_t	start, finish;			/* Pour estimer le temps de calcul		*/
double runDuration;				/* temps de calcul						*/

//vector<Constraint> eventDates; 	/* Dates de l'événement 				*/
Constraint* eventDate; 				/* Date de l'événement 				*/

vector<Track*> tracks; /* Liste contenant tous les e-tracks 		*/

/* ---------------------------------------------------------------------------- */
\end

\User functions:
/********************************************************************************/
/******///             DECLARATION DES FONCTIONS GLOBALES               ///******/
/********************************************************************************/

/* Fonction de convertion, permet de changer une valeur numérique en texte pour son affichage	*/
//template<typename T>string chiffre2string(T c) { ostringstream oss; oss << c; return oss.str(); }

void displayConstraint(Constraint c) {
	cout << "    " << c.start.hour << "h" << c.start.min << " à " << c.end.hour << "h" << c.end.min << endl;
}

void displayDate(Date d) {
	cout << "    jour: " << d.nday << " " << d.hour << ":" << d.min << ":" << d.sec << endl;
}

/*void displayEventDate() {
	cout << "Date de l'événement : Du ";

	char mbstr[100];
	char mbstr2[100];

	if (std::strftime(mbstr, sizeof(mbstr), "%F %T", &(eventDate->start))){
		std::cout << mbstr << " au ";
	}
	if (std::strftime(mbstr2, sizeof(mbstr2), "%F %T", &(eventDate->end)))
	{
		std::cout << mbstr2 << endl;
	}
}

void setEventDate() {
	string jour_debut 	= "2015-09-30 06:00:00";
	string jour_fin 	= "2015-10-01 23:59:59";

	eventDate = new Constraint();

	strptime(jour_debut.c_str(), "%F %T", &(eventDate->start));
	strptime(jour_fin.c_str(), "%F %T", &(eventDate->end));
}*/

void drawWithoutReplacement(int* src, int* dest, int n) {
	for (int k = 0; k < n; k++) {
		int index = random(k, n);
		int val = src[index];
		dest[k] = val;
		src[index] = src[k];
		src[k] = val;
	}
}

void swapValues(int* tab, int i1, int i2) {
	int tmp = tab[i2];
	tab[i2] = tab[i1];
	tab[i1] = tmp;
}

// Switch n value of the array
void switchValues(int* tab, int size, int n) {
	for (int k = 0; k < n; k++) {
		int index1 = random(0, size);
		int index2 = random(0, size);
		int tmp = tab[index2];
		tab[index2] = tab[index1];
		tab[index1] = tmp;
	}
}

vector<Constraint> parseConstraints(string subject, int day) {
    vector<Constraint> res;
    std::regex re("\\[(\\d*):(\\d*),(\\d*):(\\d*)\\]");
    std::sregex_iterator next(subject.begin(), subject.end(), re);
    std::sregex_iterator end;

    while (next != end) {
        Constraint* cons = new Constraint();
        std::smatch matches = *next;

		Date d1;
		Date d2;

		d1.nday=day;
		d1.hour=stoi(matches[1].str());
		d1.min=stoi(matches[2].str());
		d1.sec=0;

		d2.nday=day;
		d2.hour=stoi(matches[3].str());
		d2.min=stoi(matches[4].str());
		d2.sec=0;
		//s1 >> std::get_time(&tm1, "%H:%M"); // or just %T in this case
		//s2 >> std::get_time(&tm2, "%H:%M"); // or just %T in this case

		cons->start = d1;
		cons->end = d2;

		//cout << "jour " << day << " " << endl;
		//cout << matches[2].str() << endl;
		//displaytm(cons->start);
		//displaytm(cons->end);

        res.push_back(*cons);
        next++;
    }

    return res;
}

Track* findTrack(vector<Track*> tracks, int trackID) {
	for (unsigned i = 0; i < tracks.size(); i++) {
		if(tracks[i]->ID == trackID) {
			return tracks[i];
		}
	}
	return NULL;
}

Session* findSession(Track *track, int sessionID) {
	for (unsigned i = 0; i < track->sessions.size(); i++) {
		if(track->sessions[i]->ID == sessionID) {
			return track->sessions[i];
		}
	}
	return NULL;
}

void readPapersFile() {
    std::string delimiter = "|";
    ifstream fPaper;
    fPaper.open("./papers.txt", ios::in);
    string line;
    if (fPaper.is_open()) {
        while ( getline (fPaper,line) ) {

            Paper* p = new Paper();
            int i = 0;
            size_t pos = 0;
            std::string token;

            while ((pos = line.find(delimiter)) != std::string::npos) {
                token = line.substr(0, pos);
                switch ( i ) {
                    case PAPER_ID:
                        p->ID = stoi(token);
                        break;
                    case TRACK_ID:
                        p->TrackID = stoi(token);
                        break;
                    case SESSION_ID:
                        p->SessionID = stoi(token);
                        break;
                    case DURATION:
                        p->duration = stoi(token);
                        break;
                    case UTC:
                        //p->timezone = std::stod(token); // string to float
                    	break;
                    case CONSTRAINT_1:
                        p->day1 = parseConstraints(token, 0);
                        break;
                    case CONSTRAINT_2:
                        p->day2 = parseConstraints(token, 1);
                        break;
                    case CONSTRAINT_3:
                        p->day3 = parseConstraints(token, 2);
                        break;
                }
                line.erase(0, pos + delimiter.length());
                i++;
            }

			Track* track = findTrack(tracks, p->TrackID);
			if(track == NULL) {
				track = new Track();
				track->ID = p->TrackID;
				tracks.push_back(track);
			}

			Session* session = findSession(track, p->SessionID);
			if(session == NULL) {
				session = new Session();
				session->ID = p->SessionID;
				session->TrackID = p->TrackID;
				session->duration = 0;
				track->sessions.push_back(session);
			}

			session->papers.push_back(p);
        	session->duration+=p->duration;
        }
    }
}

void displayPapers(Paper p) {
    cout << "ID :" << p.ID << endl;
    cout << "TrackID :" << p.TrackID << endl;
    cout << "SessionID :" << p.SessionID << endl;
    cout << "duration :" << p.duration << endl;

    cout << "Disponibilités :" << endl;
    //Affichage des disponibilités
    cout << "  jour 1:" << endl;

    if(p.day1.size()!=0){
    	for(unsigned int i=0; i<p.day1.size(); i++)
		{
			displayConstraint(p.day1[i]);
		}
    } else {
		cout << "    Pas de contraintes" << endl;
    }

	cout << "  jour 2:" << endl;

    if(p.day2.size()!=0){
		for(unsigned int i=0; i<p.day2.size(); i++)
		{
			displayConstraint(p.day2[i]);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}

	cout << "  jour 3:" << endl;
    if(p.day3.size()!=0){
		for(unsigned int i=0; i<p.day3.size(); i++)
		{
			displayConstraint(p.day3[i]);
		}
	} else {
		cout << "    Pas de contraintes" << endl;
	}


}


int convertDateToMins(Date d) {
	return d.nday*24*60 + d.hour*60 + d.min;
}

/*
int getSessionDuration(Session* s){
	int res=0;
	for(unsigned int i=0;i<s->papers.size();i++){
		s->papers[i];
	}
	return res;
}*/


int dateOverlapping(int date1_start, int date1_end, int date2_start, int date2_end) {
	int later;
	int early;

	if(date1_start>date2_start) {
		later=date1_start;
		//cout << "date 1 commence plus tard" << endl;
	} else {
		later=date2_start;
		//cout << "date 2 commence plus tard" << endl;
	}
	if(date1_end<date2_end) {
		early=date1_end;
		//cout << "date 1 fini plus tôt" << endl;
	} else {
		early=date2_end;
		//cout << "date 2 fini plus tôt" << endl;
	}
	int score = (early-later);

	return score;
}


int dateOverlappingMins(Date d1, Date d2, int dur1, int dur2) {
	int date1_start = convertDateToMins(d1);
	int date1_end = convertDateToMins(d1)+dur1;

	int date2_start = convertDateToMins(d2);
	int date2_end = convertDateToMins(d2)+dur2;

	int score = dateOverlapping(date1_start,date1_end,date2_start,date2_end);

	/*if(score<0) {
		score=0;
	}*/
	return score;
}

int dateOverlappingMinsConstraints(Date d1, int dur1, Constraint c) {
	int date1_start = convertDateToMins(d1);
	int date1_end = convertDateToMins(d1)+dur1;

	int date2_start = convertDateToMins(c.start);
	int date2_end = convertDateToMins(c.end);

	int score = dateOverlapping(date1_start,date1_end,date2_start,date2_end);

	/*if(score<0) {
		score=0;
	}*/

	return score;
}


int evaluateConstraint(Session* s, Date date) {
	int score = 0;



	return score;
}


/* ---------------------------------------------------------------------------- */
\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end


/* ---------------------------------------------------------------------------- */

/********************************************************************************/
/*********///             DECLARATION DES CLASSES               ///**************/
/********************************************************************************/
\User classes :
Date {
	int sec;
	int min;
	int hour;
	int nday;
}

Match {
	int sessionID;
	int trackID;
	int duration;
	int order[NB_PAPERS_BY_SESSION];
	int nbPapers;
	Date date;
}

GenomeClass {
	Match match[NB_PAPERS];
}
\end

\Before everything else function:
	start = clock();

	//setEventDate();
	readPapersFile();


	cout << endl;
	//vector<Constraint> value = papers[0].day1;
	cout << endl;
	//tm start = value.start;

\end


\After everything else function:
	finish = clock();

	runDuration = (double)(finish - start) / CLOCKS_PER_SEC;
	printf("TEMPS D'EXECUTION\t:\t%2.1f secondes\n", runDuration );

	//std::cout << "Nb papers :" << papers.size() << "\n";
	std::cout << "Nb tracks :" << tracks.size() << "\n";

	int tab[tracks[0]->sessions[0]->papers.size()];
	int drawBox[tracks[0]->sessions[0]->papers.size()];
	for (unsigned int k = 0; k < tracks[0]->sessions[0]->papers.size() ; k++) {
		drawBox[k] = tracks[0]->sessions[0]->papers[k]->ID;
	}
	drawWithoutReplacement(drawBox, tab, tracks[0]->sessions[0]->papers.size());

	for (int i = 0; i < tracks[0]->sessions[0]->papers.size(); i++) {
		std::cout << "Order: " << tab[i] << "\n";
	}

	switchValues(tab, tracks[0]->sessions[0]->papers.size(), 1);

	std::cout << "\n";
	for (int i = 0; i < tracks[0]->sessions[0]->papers.size(); i++) {
		std::cout << "Order: " << tab[i] << "\n";
	}



	std::cout << "Best :" << bBest->match[0].sessionID << "\n";

	//displayPapers(papers[0]);

	//displayEventDate();
/*
	cout << "overlapping dates : " << endl;
	Date d1;

	d1.nday = 	1;
	d1.hour =	10;
	d1.min =	00;
	d1.sec = 	0;

	Date d2;

	d2.nday = 	1;
	d2.hour =	11;
	d2.min =	00;
	d2.sec = 	0;

	int dur1=30;
	int dur2=30;

	cout << " test : " << dateOverlappingMins(d1,d2,dur1,dur2);
*/
	/*cout << "overlapping constraints : " << endl;
	Date d1;

	d1.nday = 	1;
	d1.hour =	23;
	d1.min =	45;
	d1.sec = 	0;

	int dur1 =	30;

	Constraint c = papers[6].day1[0];

	displayConstraint(c);

	int test = dateOverlappingMinsConstraints(d1, dur1, c);
	cout << " test overlap : " << test << endl;*/

\end


\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
	int i = 0;
	for(unsigned int t = 0; t < tracks.size(); t++) {
		Track* track = tracks[t];
		for(unsigned int s = 0; s < track->sessions.size(); s++) {
			Session* session = track->sessions[s];

			Genome.match[i].nbPapers = session->papers.size();
			Genome.match[i].trackID = session->TrackID;
			Genome.match[i].sessionID = session->ID;
			Genome.match[i].duration = session->duration;
			//cout << "trackIDDD : " << session->TrackID << " i : " << i << " pepersize " << session->papers.size() << endl;

			int drawBox[session->papers.size()];
			for (unsigned int k = 0; k < session->papers.size() ; k++) {
				drawBox[k] = session->papers[k]->ID;
			}
			drawWithoutReplacement(drawBox, Genome.match[i].order, session->papers.size());
			Genome.match[i].date.sec = 0;
			Genome.match[i].date.min = ((int) random(0,12))*5;
			Genome.match[i].date.hour = (int) random(0,24);
			Genome.match[i].date.nday = (int) random(0, NB_DAYS);
			i++;
		}
	}
\end

\GenomeClass::crossover :
	// must create "child" out of "parent1" and "parent2"
	float limit = 0.5;

	for (unsigned int i=0; i<NB_SESSIONS; i++)
	{
		if((float)random(0.,1.) < limit)
		{ child.match[i].date = parent2.match[i].date; }
	}
\end

\GenomeClass::mutator : // Must return the number of mutations
	unsigned int nbMutations = 0;
	for(unsigned int i = 0; i < NB_SESSIONS; i++) {
		if (tossCoin(pMutPerGene)){
			//drawWithoutReplacement(Genome.match[i].order, Genome.match[i].nbPapers);
			Genome.match[i].date.sec = 0;
			Genome.match[i].date.min = ((int) random(0,12))*5; 	//0 à 55
			Genome.match[i].date.hour = (int) random(0,24);		//0 à 23
			Genome.match[i].date.nday = (int) random(0, NB_DAYS);

			nbMutations++;
		}

		int nbSwitch = random(0, Genome.match[i].nbPapers);
		switchValues(Genome.match[i].order, Genome.match[i].nbPapers, nbSwitch);

	}
	return nbMutations;
\end

\GenomeClass::evaluator : // Returns the score as a real value
	// Must return an evaluation of the quality of the "Genome"
	//float val[NB_PAPERS];
	float res = 0.;
	float overlapTrack15 = 0.;
	float overlapDisponibility = 0.;

	//float overlapDisponibility = 0.;

	//Track* track15 = findTrack(tracks, 15);
	//Session* session15;


	//Evaluator to let track 15 alone
	for(unsigned int s = 0; s < NB_SESSIONS; s++) { //get track 15 sessions
		if(Genome.match[s].trackID == 15) {
			for(unsigned int i = 0; i < NB_SESSIONS; i++) { //compare to other sessions dates

				if(Genome.match[i].trackID == 15 && Genome.match[i].sessionID == Genome.match[s].sessionID) {
					//Nothing to do
				} else {
					overlapTrack15-=dateOverlappingMins(Genome.match[i].date, Genome.match[s].date, Genome.match[i].duration, Genome.match[s].duration);
					//cout <<dateOverlappingMins(Genome.match[i].date, Genome.match[s].date, Genome.match[i].duration, Genome.match[s].duration) << endl;
				}

				/*
				Genome.match[i].date.sec = 0;
				Genome.match[i].date.min = ((int) random(0,12))*5; 	//0 à 55
				Genome.match[i].date.hour = (int) random(0,24);		//0 à 23

				Genome.match[i].date.nday = (int) random(0, NB_DAYS);*/
			}
		}
	}

	Session* currentSession;
	Track* currentTrack;
	//Evaluator to respect the disponibility constraints
	for(unsigned int i = 0; i < NB_SESSIONS; i++) { //loop on sessions

		//currentTrack = findTrack(tracks, Genome.match[i].trackID);
		//currentSession = findSession(currentTrack, Genome.match[i].sessionID);

		//evaluateConstraint(currentSession, Genome.match[i].date);


	}

	res+=overlapTrack15;
  	return res;
\end

\User Makefile options:
CPPFLAGS+=-std=c++11
\end

/*mutation et crossover à 0 pour seqfault*/
\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 100    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 64		   //POP_SIZE
  Offspring size : 64// or a xx%
  Mutation probability : 0.8       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximise      // maximise
  Selection operator: Tournament 0.6
  Surviving parents: 100%        // Percentage or absolute
  Surviving offspring: 100%      // Percentage or absolute  d
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:true
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  //Remote island model: true
  //IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.3    // Probability of sending an individual per generation
  //Server port : 2929

  Save population: false
  //Start from file:false
\end
